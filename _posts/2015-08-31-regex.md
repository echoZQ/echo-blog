---
layout: post
title: 正则表达式
category: 技术
tags: Javascript
---

### 什么是正则表达式(Regular Expression)
正则表达式通常用来检索和替换那些符合某个模式(逻辑公式)的**文本**(即它是用来进行字符串操作的),通常缩写成regex.

使用正则表达式我们可以:  
1.判断给定的字符串是否符合过滤逻辑；  
2.从给定的字符串中获取我们想要的部分。

### 正则表达式的常用符号(百度百科)
正则表达式由一些**普通字符**和**元字符**组成。普通字符包括大小写的字母和数字，而元字符包含了很多特殊的含义。

元字符  | 描述           
-------|----------------
\      | 转义字符，将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“\\\n”匹配\n。“\n”匹配换行符。序列“\\\”匹配“\”而“\\(”则匹配“(” 
^      | 匹配输入字符串开始的位置       
$      | 匹配输入字符串结束的位置      
*      | 匹配**前面的子表达式**任意次，如zo*能匹配"z","zo","zoo",就是说o就是子表达式
+      | 匹配前面的子表达式**一次或多次(>=1)**,如zo+能匹配"zo", "zoo",但是不能匹配"z"
?      | 匹配前面的子表达式**零次或一次**, 如do(es)?可以匹配"do"或者"does"(三元表达式的味道)
{n}    | n为非负整数，匹配确定的n次，如o{2}不能匹配"Bob"但是可以匹配"foolish" 
{n,}   | n为非负整数，**至少匹配n次**，如o{2}不能匹配"Bob"但是可以匹配"fooooolish", o{1,}相当于"o+",o{0,}相当于"o\*"
{n,m}  | m,n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意**在逗号和两个数之间不能有空格**。
?      | 当该字符紧跟在任何一个其他限制符（\*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而**默认的贪婪模式**则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。
.      | 匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式
x\|y   | 匹配x或y。例如，“z|food”能匹配“z”或“food”或"zood"(此处请谨慎)。“(z|f)ood”则匹配“zood”或“food”。
[xyz]  | 匹配所包含的**任意一个**字符(非所有字符)，例如，“[abc]”可以匹配“plain”中的“a” 
[^xyz] | 匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin” 
[a-z]  | 字符范围 |
[^a-z] | 不在字符范围 |
\b     | 匹配一个单词边界，也就是指**单词和空格间的位置**（即**正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置**，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er” 
\B     | 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er” 
\d     | 匹配一个数字字符。等价于[0-9] 
\D     | 匹配一个非数字字符。等价于[^0-9] 
\n     | 匹配换行符 
\r     | 匹配回车符 
\s     | 匹配任何不可见字符，包括空格、制表符、换页符等等 
\S     | 匹配任何可见字符 
\w     | 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]” 
\W     | 匹配任何非单词字符。等价于“[^A-Za-z0-9_]” 
\\< \\>  | 匹配**词**（word）的开始（\\<）和结束（\\>）。例如正则表达式\<the\>能够匹配字符串"for the wise"中的"the"，但是不能匹配字符串"otherwise"中的"the" 
\\( \\)  | 将 \( 和 \) 之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域，<span style="color: red;">（一个正则表达式中最多可以保存9个,js中并非如此），它们可以用 \1 到\9 的符号来引用,js中不是\\而是$</span>
\|      | 将两个匹配条件进行逻辑“或”（Or）运算 

单个大写字母与小写字母含义相反，小写是，大写非

### 速记理解
正则的难点在于它有很多等价字符:  

?等价于{0,1}  
*等价于{0,}  
+等价于{1,}
\d等价于[0,9]   digit  
\w等价于[A-Za-z_0-9] 

^ 开始  
$ 结尾  
() 域段  
[] 包含  
[^] 不包含  
{n,m} 匹配长度  
. 任何单个字符(\. 字符点)  
| 或
\ 转义   
, 分隔 

#### 示例
示例1: 将所有方法foo(a,b,c)的实例改为foo(b,a,c)
	
	//$1、$2、...、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本
	var target = "a,b,c";
	console.log(target.replace(/([^,]*),([^,]*),([^,]*)/, "$2,$1,$3")); //b,a,c

	//注意其他语言的临时区域可能是用\1,\2等方式表示,()需要转义
	var target1 = "foo(a,b,c)";
	console.log(target1.replace(/foo\(([^,]*),([^,]*),([^,]*)\)/g, "foo($2,$1,$3)")); //foo(b,a,c)
	
	//一个正则表达式中最多可以保存9个这句话从此例来看是不对的
	var target2 = "a,b,c,d,e,f,g,h,i,j,k";
	console.log(target2.replace(/([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*)/, "$11, $10, $9, $8, $7, $6, $5, $4, $3, $2, $1")); //k, j, i, h, g, f, e, d, c, b, a
注意: js中对组的定义并非上述表格中的\\( \\)，\\确实是转义字符,([^,]*)表示匹配非逗号的字符并保存到临时区域

示例2: 替换指定内容到行尾
	
	var string = "123 abc f";
	console.log(string.replace(/abc.*/, "hello world")); //123 hello world
	
示例3: 给字符串中的数字加[]

	//$& 与 regexp 相匹配的子串
	var string1 = "abc123def567gh";
	console.log(string1.replace(/\d+/g,"[$&]")); //abc[123]def[567]gh  
	
示例4：删除某行末尾的特定字符
	
	var string2 = "1212abc 2323abcre 232abc";
	console.log(string2.replace(/abc$/g, "")); //1212abc 2323abcre 232
	

### 零宽断言
用于查找在某些内容(**但并不包括这些内容**)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置(正则的两种匹配，匹配字符和匹配位置)，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。

(?=exp):零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp:
	
	var string = "I'm singing while you're dancing";
	console.log(string.replace(/\b\w+(?=ing\b)/g, "laugh"));

(?<=exp):零宽度正回顾后发断言(javascript不支持)
	
	//node 直接报错
	var string2 = "reading a book";
	console.log(string2.replace(/(?<=\bre)\w+\b/, "view")); //SyntaxError: Invalid regular expression: /(?<=\bre)\w+\b/: Invalid group
	
### 负向零宽
(?!exp):零宽度负预测先行断言,断言此位置的后面不能匹配表达式exp

	//我只能爱老婆，不能爱小三
	var string3 = "我爱老婆";
	var string4 = "我爱小三";
	console.log(string3.search(/我爱(?!小三)/)); //0
	console.log(string4.search(/我爱(?!小三)/)); //-1
	
### javascript中的正则  
RegExp对象表示正则表达式

	直接量语法(字面量是声明方式)，注意pattern不能是字符串(即不要用“”)
	/pattern/attributes
	
	创建 RegExp 对象的语法：参数attributes可选，包含属性 "g"、"i" 和 "m"，分别用于指定全局匹配、区分大小写的匹配和多行匹配
	new RegExp(pattern, attributes);

####js的RegExp对象有三个方法(<span style="color: red">对象方法</span>):     
test():检索字符串中的指定值。**返回值是true或false**  
exec():检索字符串中的指定值。**返回值是被找到的值**。如果没有发现匹配，则返回null。(exec可以说是test的升级版本，因为它不仅可以检测，而且检测到了可以直接提取结果。)  
	
	var string = "you love me and I love you";
	var pattern = /you/g;
	//如果使用 “g” 参数，exec()的工作原理如下:1.找到第一个 “you”，并存储其位置; 2:如果再次运行exec()，则从存储的位置（lastIndex）开始检索，并找到下一个“you”，并存储其位置(我们可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0)
	console.log(pattern.exec(string)); //[ 'you', index: 0, input: 'you love me and I love you' ]
	console.log(pattern.exec(string)); //[ 'you', index: 23, input: 'you love me and I love you' ]
	console.log(pattern.exec(string)); //null
	
	
	//此示例中输出的第0个元素是与正则表达式相匹配的文本，第1个元素是与RegExpObject的第1个子表达式相匹配的文本（如果有的话），第2个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。子表达式就是pattern里（）内的东西
	var s = 'you love me and I love you';
	var pattern = /y(o?)u/;
	var ans = pattern.exec(s);
	console.log(ans);   // ["you", "o", index: 0, input: "you love me and I love you"]
	console.log(ans.length) // 2  index和input只是数组属性
compile():用于改变 RegExp,既可以改变检索模式，也可以添加或删除第二个参数  

####支持正则表达式的<span style="color: red">String对象的方法</span>:  
search:检索与正则表达式相匹配的值（test只能判断有木有，search还能返回位置！当然test()如果有需要能继续找下去，而search则会自动忽略g（如果有的话），与string的indexOf相比，indexOf方法可以从指定位置开始查找，但是不支持正则）
	
	var string = "zhao qian";
	//第一个与regexp相匹配的子串的起始位置,没有找到任何匹配的子串，则返回 -1
	console.log(string.search(/qian/)); //5
	console.log(string.search(/美/)); //-1
	//search() 方法不执行全局匹配，它将忽略标志g,总是返回stringObject的第一个匹配的位置
	console.log(string.search(/a/)); //2

match:找到一个或多个正则表达式的匹配,很大程度上有赖于regexp是否具有标志g
	
	//此例不含全局属性
	var str = "Hello world!";
	//找到了一个或多个匹配子串，则返回一个数组
	console.log(str.match("world")); //[ 'world', index: 6, input: 'Hello world!' ]
	//没有找到任何匹配的子串，则返回 null
	console.log(str.match("world").length); //1
	console.log(str.match("World")); //null
	console.log(str.match("worlld")); //null
	console.log(str.match("world!")); //[ 'world!', index: 6, input: 'Hello world!' ]
	replace:替换与正则表达式匹配的子串  
	
	//全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是 stringObject 中所有的匹配子串，而且也没有 index 属性或 input 属性
	var str1 = "1 plus 2 equal 3";
	console.log(str1.match(/\d+/g)); //[ '1', '2', '3' ]
	
replace: 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。stringObject.replace(regexp/substr,replacement)。replacement**可以是一个字符串也可以是一个函数**  

字符  |  描述               
-----|-----  
$1、$2、...、$99	 | 与 regexp 中的第1到第99个子表达式相匹配的文本。  
$& | 与 regexp 相匹配的子串。  
$` | 位于匹配子串左侧的文本。  
$' | 位于匹配子串右侧的文本。  
$$ | 直接量符号。  

	var string3 = "aaa bbb ccc";
	console.log(string3.replace(/\b\w+\b/g, function(word) {
		return word.substring(0, 1).toUpperCase() + word.substring(1);
	})); //Aaa Bbb Ccc
	
split:把字符串分割为字符串数组。stringObject.split(separator, howmany)
	
	var str = "How are you doing today?";

	console.log(str.split(" ")); //[ 'How', 'are', 'you', 'doing', 'today?' ]
	console.log(str.split("")); 
	console.log(str.split(" ",3)); //[ 'How', 'are', 'you' ]

### 参考链接
[我所认识的JavaScript正则表达式](http://www.php100.com/html/it/biancheng/2015/0320/8825.html)  
[w3school JavaScript RegExp 对象](http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp)
